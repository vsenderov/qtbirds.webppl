/**
 * 
 * @param currCharState starting phenotypic character state
 * @param n number of transitions
 * @param phenotypeModel phenotype model
 * @returns 
 */
var evolveChar = function(currCharState, n, phenotypeModel) {
  if (n == 0) {
    return currCharState
  } else { // transition
    var endCharState = sample(Categorical({
      ps: phenotypeModel.P[currCharState],
      vs: phenotypeModel.nextStates[currCharState]
    }))
    return evolveChar(endCharState, n - 1, phenotypeModel)
  }
}

/**
 * Evolves a single molecular state and counts the numbe of additional phenotype transitions
 * @param currTime time at the beginning of the function call
 * @param currState molecular state at the beginning of the function call
 * @param numCharTrans number of character transitions at the beginning of the function call
 * @param time total time of evolution (end condtion)
 * @param phenotypeModel (object)
 * @param molecularModel (object)
 * @param mixedModel (object)
 * @returns {endState, numCharTrans}
 */
var singleStateEvolution = function(currTime, currState, numCharTrans, time, phenotypeModel, molecularModel, mixedModel) {
  var tLam = safeexp(-phenotypeModel.rate*phenotypeModel.Q[1][1]) // Limitation, all diag elmnts must be the same
  var tMu = safeexp(-molecularModel.rate*molecularModel.Q[currState][currState])  
  var tNu = safeexp(mixedModel.rate*phenotypeModel.Q[1][1]*molecularModel.Q[currState][currState])
  // TODO add the rates, instead, perhaps?

  var tArr = [tLam, tMu, tNu]
  var eventTime = reduce(function(previous, current) {
    return Math.min(previous, current)
  }, tArr[0], tArr)
  if (currTime + eventTime > time) { // we are done, future
    return {endState: currState, numCharTrans: numCharTrans}
  }
  var caseT = [tLam, tMu, tNu].indexOf(eventTime);
  if (caseT == 0) {  // pure character change
    return singleStateEvolution(currTime + eventTime, currState, numCharTrans + 1, time, phenotypeModel, molecularModel, mixedModel)
  } 
  if (caseT == 1) { // pure molecular subs
    var endState = sample(Categorical({
      ps: molecularModel.P[currState],
      vs: molecularModel.nextStates[currState]
    }))
    return singleStateEvolution(currTime + eventTime, endState, numCharTrans, time, phenotypeModel, molecularModel, mixedModel)
  }
  if (caseT == 2) { // both
    var endState = sample(Categorical({
      ps: molecularModel.P[currState],
      vs: molecularModel.nextStates[currState]
    }))
    return singleStateEvolution(currTime + eventTime, endState, numCharTrans + 1, time, phenotypeModel, molecularModel, mixedModel)
  } 
}


/**
 * Evolves a single molecular state (nucleotide) using algorithm 2
 * @param currTime time at the beginning of the function call
 * @param currState molecular state at the beginning of the function call
 * @param numSJumps number of s-jumps
 * @param time total time of evolution (end condtion)
 * @param molecularModel (object)
 * @param p probability of an s-jump affecting any given nucleotide
 * @returns endState
 */
var singleStateEvolution2 = function(currTime, currState, numSJumps, time, molecularModel, p) {
  /* Using Jan's walk so to say
   (vsend, 23-05-04) For this to work, all diag elmnts of Q must be the same I think
  */  
  var numNJumps = sample(Poisson( {mu: (molecularModel.mu * time + numSJumps * p)} ))

  // do the transition numNJumps time - recursion
  var f = function(n, state) {
    if (n == 0) return state
    else {
      var newState = sample(Categorical({
        ps: molecularModel.P[state],
        vs: molecularModel.nextStates[state]
      }))
      return f(n - 1, newState)
    }
  }

  var endState = f(numNJumps, currState)
  return endState
}


/**
 * Helper to able to call the exponential waiting with any parameter
 * @param rate of the exponential distribution
 * @returns the actual waiting time if rate is in the support of the exponential
 *  distribution, Infinity otherwise
 */
var safeexp = function(rate) {
  if (rate <= 0) {
    return Infinity 
  } else return exponential({a: rate})
}


/**
 * Straight line (branch) evolution
 * 
 * Current limitation! Diagonal elements of QChar must be same, because
 * we are not actually making the character transitions but only counting them.
 * 
 * @param lam Rate of character evolution (character transitions per My)
 * @param mu Rate of molecular evolution (nucleotide substitutions per site per My)
 * @param nu Rate of simultaneous evolution (nucleotide subssitutions per site per My and character transitions per My)
 * @param time time of evolution (branch length in My)
 * @param startStateSeq 
 * @param Q Substitution matrix
 * @param P Transition probabilities for molecular evolution
 * @param nextStates 
 * @param startCharState 
 * @param QChar Sustitution matrix for the character transtions 
 * @param PChar Transition probabilities for character evolution
 * @param nextStatesChar
 * @returns  {endStates, endCharState}
 */
var evolve = function( time, startStateSeq, startCharState, phenotypeModel, molecularModel, mixedModel) {  
  var f = function(startState) {
    return singleStateEvolution(0, startState, 0, time, phenotypeModel, molecularModel, mixedModel)
  }
  // Do the single state evolution for each of starting states
  var mapResult =  map(f, startStateSeq)
  var map_proj = function(mr, field) {
    return (mr[field])
  }
  var proj_endState = function(mr) {
    return map_proj(mr, "endState")
  }
  var proj_numCharTrans = function(mr) {
    return map_proj(mr, "numCharTrans")
  }
  // Extract end states and total number of transitions from resulting object
  var endStates = map(proj_endState, mapResult)
  var numCharTrans = sum(map(proj_numCharTrans, mapResult))
  // Evolve the characters as well
  
  var endCharState = evolveChar(startCharState, numCharTrans, phenotypeModel)

  return {endStates, endCharState}
}


/**
 * Straight line (branch) evolution (algorithm 2)
 * 
 * Current limitation! Diagonal elements of QChar must be same, because
 * we are not actually making the character transitions but only counting them.
 * 
 * @param lam Rate of character evolution (character transitions per My)
 * @param mu Rate of molecular evolution (nucleotide substitutions per site per My)
 * @param nu Rate of simultaneous evolution (nucleotide subssitutions per site per My and character transitions per My)
 * @param time time of evolution (branch length in My)
 * @param startStateSeq 
 * @param Q Substitution matrix
 * @param P Transition probabilities for molecular evolution
 * @param nextStates 
 * @param startCharState 
 * @param QChar Sustitution matrix for the character transtions 
 * @param PChar Transition probabilities for character evolution
 * @param nextStatesChar
 * @returns  {endStates, endCharState}
 */
var evolve2 = function( time, startStateSeq, startCharState, phenotypeModel, molecularModel, mixedModel) {  
  // sample the number of s-jumps
  var numSJumps = sample(Poisson({mu: (mixedModel.nu * time) }))
  var p = 1/startStateSeq.length

  var f = function(startState) {
    return singleStateEvolution2(0, startState, numSJumps, time, molecularModel, p)
  }
  // Do the single state evolution for each of starting states
  var endStates =  map(f, startStateSeq)
  
  // Evolve the characters as well
  var numCharTrans = sample(Poisson({mu: (phenotypeModel.lam * time + numSJumps)})) 
  // TODO think if this should not be sample(Poisson({mu: (phenotypeModel.lam * time)}) + numSJumps
  // (vsend 2023-08-12) yes, of course, these jumps have already happened

  var endCharState = evolveChar(startCharState, numCharTrans, phenotypeModel)

  return {endStates, endCharState}
}


/**
 * Evolves the model along a supplied tree
 * 
 * 
 * @param tree where you start the evolution
 * @param evolutionFunction which function to use to evolve the branches of the tree
 * @param time this should not be a parameter of the function, it should be calculated 
 * @param startStateSeq 
 * @param startCharState 
 * @param phenotypeModel 
 * @param molecularModel 
 * @param mixedModel 
 * @returns 
 */
var evolveTree = function(tree, evolutionFunction, startStateSeq, startCharState, phenotypeModel, molecularModel, mixedModel) {  
  var toNucs = function(s) {
    return molecularModel.nucleotides[s]
  }

  if(tree.type == 'node') {
    var leftEvolution = evolve(tree.age - tree.left.age, startStateSeq, startCharState, phenotypeModel, molecularModel, mixedModel)
    var rightEvolution = evolve(tree.age - tree.right.age, startStateSeq, startCharState, phenotypeModel, molecularModel, mixedModel)
    //var leftNucs = map(toNucs, leftEvolution.endStates).join('')
    //var rightNucs = map(toNucs, rightEvolution.endStates).join('')
    var left = evolveTree(tree.left, evolutionFunction, leftEvolution.endStates, leftEvolution.endCharState, phenotypeModel, molecularModel, mixedModel)
    var right = evolveTree(tree.right, evolutionFunction, rightEvolution.endStates, rightEvolution.endCharState, phenotypeModel, molecularModel, mixedModel)
    return {
      type: 'node',
      left: left,
      right: right,
      age: tree.age,
      index: tree.index
    }
  }
  if (tree.type == 'leaf') {
    
    return {
      type: 'leaf',
      age: tree.age,
      index: tree.index,
      sequence: map(toNucs, startStateSeq).join(''),
      character: phenotypeModel.characters[startCharState],
      stateSequence: startStateSeq, // to avoid having to decode again
      characterState: startCharState
    }
  }
}


/**
 * Coalesces an annotated tree
 * 
 *   - does not decode the tips
 * 
 * @param annotTree 
 * @param fun 
 * @param phenoMod
 * @param molMod
 * @param mixedMod
 * 
 * @return Collapses the tree as one "leaf", which has the coaleseced sequence and character
 *   at the root.  Also conditions the weight in the process.
 */
var coalesce_annotatedTree = function(annotTree,  phenotypeModel, molecularModel, mixedModel) {
  // if both and left and right are leaves, we have a binary path tree and we can run
  // conditional sequence evolutionbackwards
  if (annotTree.left.type == 'leaf' && annotTree.right.type == 'leaf') {
    return (coalesce_binaryPathTree(annotTree, phenotypeModel, molecularModel, mixedModel))
  } else if (annotTree.left.type == 'leaf' && annotTree.right.type == 'node') {
    var newTree = {
      type: 'node',
      left: annotTree.left,
      right: coalesce_annotatedTree(annotTree.right,  phenotypeModel, molecularModel, mixedModel),
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree(newTree, phenotypeModel, molecularModel, mixedModel))
  } else if (annotTree.left.type == 'node' && annotTree.right.type == 'leaf') {
    var newTree = {
      type: 'node',
      left: coalesce_annotatedTree(annotTree.left,  phenotypeModel, molecularModel, mixedModel),
      right: annotTree.right,
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree(newTree, phenotypeModel, molecularModel, mixedModel))
  } else {
    var newTree = {
      type: 'node',
      left: coalesce_annotatedTree(annotTree.left,  phenotypeModel, molecularModel, mixedModel),
      right: coalesce_annotatedTree(annotTree.right,  phenotypeModel, molecularModel, mixedModel),
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree(newTree, phenotypeModel, molecularModel, mixedModel))
  }
}


/**
 * Coalesces an annotated tree algorithm 2
 * 
 * (vsend, 2023-08-12) needs review probably wrong as probably mixes continuoys and discrete processes;
 * for now we are abandoning algorithm 2 anyway
 * 
 *   - does not decode the tips
 *   -
 * 
 * @param annotTree 
 * @param fun 
 * @param phenoMod
 * @param molMod
 * @param mixedMod
 * 
 * @return Collapses the tree as one "leaf", which has the coaleseced sequence and character
 *   at the root.  Also conditions the weight in the process.
 */
var coalesce_annotatedTree2 = function(annotTree,  phenotypeModel, molecularModel, mixedModel) {
  // if both and left and right are leaves, we have a binary path tree and we can run
  // conditional sequence evolutionbackwards
  if (annotTree.left.type == 'leaf' && annotTree.right.type == 'leaf') {
    return (coalesce_binaryPathTree2(annotTree, phenotypeModel, molecularModel, mixedModel))
  } else if (annotTree.left.type == 'leaf' && annotTree.right.type == 'node') {
    var newTree = {
      type: 'node',
      left: annotTree.left,
      right: coalesce_annotatedTree2(annotTree.right,  phenotypeModel, molecularModel, mixedModel),
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree2(newTree, phenotypeModel, molecularModel, mixedModel))
  } else if (annotTree.left.type == 'node' && annotTree.right.type == 'leaf') {
    var newTree = {
      type: 'node',
      left: coalesce_annotatedTree2(annotTree.left,  phenotypeModel, molecularModel, mixedModel),
      right: annotTree.right,
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree2(newTree, phenotypeModel, molecularModel, mixedModel))
  } else {
    var newTree = {
      type: 'node',
      left: coalesce_annotatedTree2(annotTree.left,  phenotypeModel, molecularModel, mixedModel),
      right: coalesce_annotatedTree2(annotTree.right,  phenotypeModel, molecularModel, mixedModel),
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree2(newTree, phenotypeModel, molecularModel, mixedModel))
  }
}


/**
 * Coalesces an annotated tree Algorithm 1 -- message passing version
 * 
 *   - does not decode the tips
 *   
 * 
 * @param annotTree 
 * @param fun 
 * @param phenoMod
 * @param molMod
 * @param mixedMod
 * 
 * @return Collapses the tree as one "leaf", which has the coaleseced sequence and character
 *   at the root.  Also conditions the weight in the process.
 */
var coalesce_annotatedTree_mp = function(annotTree,  phenotypeModel, molecularModel, mixedModel) {
  // if both and left and right are leaves, we have a binary path tree and we can run
  // conditional sequence evolutionbackwards
  if (annotTree.left.type == 'leaf' && annotTree.right.type == 'leaf') {
    return (coalesce_binaryPathTree_mp(annotTree, phenotypeModel, molecularModel, mixedModel))
  } else if (annotTree.left.type == 'leaf' && annotTree.right.type == 'node') {
    var newTree = {
      type: 'node',
      left: annotTree.left,
      right: coalesce_annotatedTree_mp(annotTree.right,  phenotypeModel, molecularModel, mixedModel),
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree_mp(newTree, phenotypeModel, molecularModel, mixedModel))
  } else if (annotTree.left.type == 'node' && annotTree.right.type == 'leaf') {
    var newTree = {
      type: 'node',
      left: coalesce_annotatedTree_mp(annotTree.left,  phenotypeModel, molecularModel, mixedModel),
      right: annotTree.right,
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree_mp(newTree, phenotypeModel, molecularModel, mixedModel))
  } else {
    var newTree = {
      type: 'node',
      left: coalesce_annotatedTree_mp(annotTree.left,  phenotypeModel, molecularModel, mixedModel),
      right: coalesce_annotatedTree_mp(annotTree.right,  phenotypeModel, molecularModel, mixedModel),
      age: annotTree.age,
      index: annotTree.index
    }
    return (coalesce_binaryPathTree_mp(newTree, phenotypeModel, molecularModel, mixedModel))
  }
}


/**
 * Like coalesce but returns a "leaf" with a sequence on it
 * @param binaryPathTree - tree with decoded sequences, which only has two leafs.
 * @param phenotypeModel 
 * @param molecularModel 
 * @param mixedModel 
 * @return "leaf"
 */
var coalesce_binaryPathTree = function(binaryPathTree, phenotypeModel, molecularModel, mixedModel) {
  // Idea: resursively process the two sequences together, evolving every nucleotide
  // to the beginning of the branch and then conditioning on the same outcome
  // then process the phenotypic character
  // Note: we can use the singleStateEvolution function but we have to make sure
  // invert the models (invert the Q-matrix) if they are not symmetric. Transpose, I think
  var time = binaryPathTree.age - binaryPathTree.left.age // right should be the same
  var leftStartStateSeq = binaryPathTree.left.stateSequence
  var rightStartStateSeq = binaryPathTree.right.stateSequence
  var leftStartCharState = binaryPathTree.left.characterState
  var rightStartCharState = binaryPathTree.right.characterState

  if (!(leftStartStateSeq.length == rightStartStateSeq.length)) {
    console.log("Sequences of differing length!")
    return -Infinity
  }

  var N = leftStartStateSeq.length

  // conditions and returns the total number of character transitions
  var f = function(i, leftNumTrans, rightNumTrans, coalescedStateSequence) {
    if (i == N) { // we are done
      return {leftNumTrans, rightNumTrans, coalescedStateSequence}
    } else {
      var leftRes = singleStateEvolution(0, leftStartStateSeq[i], 0, time, phenotypeModel, molecularModel, mixedModel)
      var rightRes = singleStateEvolution(0, rightStartStateSeq[i], 0, time, phenotypeModel, molecularModel, mixedModel)

      condition(  leftRes.endState == rightRes.endState )
      return f(i + 1, leftNumTrans + leftRes.numCharTrans, rightNumTrans + rightRes.numCharTrans, coalescedStateSequence.concat(leftRes.endState))
    }
  }

  var backwardsSequenceEvolution = f(0, 0, 0, [])

  // now evolve the phenotypic character numTrans.leftNumTrans times on the left
  // and numTrans.rightNumTrans on the right and condition that they ended up the
  // same
  var leftCharState = evolveChar(leftStartCharState, backwardsSequenceEvolution.leftNumTrans, phenotypeModel)
  var rightCharState = evolveChar(rightStartCharState, backwardsSequenceEvolution.rightNumTrans, phenotypeModel)

  condition(leftCharState == rightCharState)
 
  var toNucs = function(s) {
    return molecularModel.nucleotides[s]
  }

  return {
    type: 'leaf',
    age: binaryPathTree.age,
    index: binaryPathTree.index,
    sequence: map(toNucs, backwardsSequenceEvolution.coalescedStateSequence).join(''),
    character: phenotypeModel.characters[leftCharState],
    stateSequence: backwardsSequenceEvolution.coalescedStateSequence, // to avoid having to decode again
    characterState: leftCharState
  } 
}


/**
 * converts the stateSequence of a node or leaf to a messageSequence
 * if it does not exist, or gets it if it exists
 * @param node
 */
var getMessageSequence = function(node) {
  var getMessage = function(state) {
    return messages[state]
  }
  if (node.messageSequence) {
    return node.messageSequence
  } else { // takes care of the original leaves
    return(map(getMessage, node.stateSequence))
  }
}


var getSingleNucMessage = function(i, node) {
  var getMessage = function(state) {
    return messages[state]
  }
  if (node.singleNucMessage) {
    if (node.position != i) {
      console.error("Single nucleotide mismatch")
      factor(-Infinity)
    }
    return node.singleNucMessage
  } else {
    var mesSeq = map(getMessage, node.stateSequence)
    return mesSeq[i]
  }
}


var getCharacterMessage = function(node, nChar) {
  var getMessage = function(state) { 
    return possible_message_states(nChar)[state]
  }
  if (node.characterMessage) {
    return node.characterMessage 
  } else { // takes care of the original leaves
    return getMessage(node.characterState)
  }
}


// Gets the combined message of the nucleotide and the character at that position
// For now we only support JC-69 x Mk
var getCombinedMessage = function(i, node) {
  if (node.combinedMessage) return node.combinedMessage
  else {   
    var combinedState = node.stateSequence[i]*2 + node.characterState
    return messJC69x2stateMk[combinedState]
  }
}


/**
 * Like coalesce but returns a "leaf" with a sequence on it
 *    (algorithm 2)
 * 
 * 2023-08-12 probably wrong as can mix continuous and discrete processes
 * 
 * @param binaryPathTree - tree with decoded sequences, which only has two leafs.
 * @param phenotypeModel 
 * @param molecularModel 
 * @param mixedModel 
 * @return "leaf"
 */
var coalesce_binaryPathTree2 = function(binaryPathTree, phenotypeModel, molecularModel, mixedModel) {
  var leftTime = binaryPathTree.age - binaryPathTree.left.age
  var rightTime = binaryPathTree.age - binaryPathTree.right.age

  var leftMesSeq = getMessageSequence(binaryPathTree.left)
  var rightMesSeq = getMessageSequence(binaryPathTree.right)

  var leftCharMes = getCharacterMessage(binaryPathTree.left, phenotypeModel.characters.length)
  var rightCharMes = getCharacterMessage(binaryPathTree.right, phenotypeModel.characters.length)

  if (!(leftMesSeq.length == rightMesSeq.length)) {
    console.log("Messages of differing length!")
    return -Infinity
  }

  var N = leftMesSeq.length 

  // we ought to take care of the s-jumps here!
  var leftNs = poisson({mu: mixedModel.rate * leftTime})
  var rightNs = poisson({mu: mixedModel.rate * rightTime})
  var p = 1/N

  /**
   * Computes the transient state probabilities after simulating evolution along
   * a branch
   * 
   * @param mesSeq an array the length of the nucleotide sequence,
   *               the elements of which are vectors containing probabilities
   *               for being in each of the allowable states at that place
   *               in the sequence
   * @param Q substitution rate matrix
   * @param time evolution time
   * @param s additional time due to s jumps
   */
  var computeProbSeq = function(mesSeq, time, s) {
    var p = function(m) {
      mExpQtrs(m, molecularModel.Q, time, molecularModel.rate, s)
    }
    return map(p, mesSeq)
  }

  var leftProbSeq = computeProbSeq(leftMesSeq, leftTime, leftNs*p)
  var rightProbSeq = computeProbSeq(rightMesSeq, rightTime, rightNs*p)
  // now these will become the new messages after coalescing
  // elementwise leftProbSeq and rightProbSeq to get newMessageSequence
  var newMessageSequence = mapN(function(i) { return mathjs.dotMultiply(leftProbSeq[i], rightProbSeq[i]).valueOf() }, N)

  var computeCharProb = function(charMes, time, s) {
    return  mExpQtrs(charMes, phenotypeModel.Q, time, phenotypeModel.rate, s)
  }

  var leftCharMes = computeCharProb(leftCharMes, leftTime, leftNs)
  var rightCharMes =  computeCharProb(rightCharMes, rightTime, rightNs)

  var newCharacterMessage = mathjs.dotMultiply(leftCharMes, rightCharMes).valueOf()

  return {
    type: 'leaf',
    age: binaryPathTree.age,
    index: binaryPathTree.index,
    messageSequence: newMessageSequence, // to avoid having to decode again
    characterMessage: newCharacterMessage
  } 
}



/**
 * Like coalesce but returns a "leaf" with a sequence on it
 *    (algorithm 1 but with message passing)
 * 
 * @param binaryPathTree - tree with decoded sequences, which only has two leafs.
 * @param phenotypeModel 
 * @param molecularModel 
 * @param mixedModel 
 * @return "leaf"
 */
var coalesce_binaryPathTree_mp = function(binaryPathTree, phenotypeModel, molecularModel, mixedModel) {
  var leftTime = binaryPathTree.age - binaryPathTree.left.age
  var rightTime = binaryPathTree.age - binaryPathTree.right.age

  var leftMesSeq = getMessageSequence(binaryPathTree.left)
  var rightMesSeq = getMessageSequence(binaryPathTree.right)

  var leftCharMes = getCharacterMessage(binaryPathTree.left, phenotypeModel.characters.length)
  var rightCharMes = getCharacterMessage(binaryPathTree.right, phenotypeModel.characters.length)

  if (!(leftMesSeq.length == rightMesSeq.length)) {
    console.log("Messages of differing length!")
    return -Infinity
  }

  var N = leftMesSeq.length 

  // we ought to take care of the s-jumps here!
  //var leftNs = poisson({mu: mixedModel.rate * leftTime})
  //var rightNs = poisson({mu: mixedModel.rate * rightTime})
  //var p = 1/N

  /**
   * Computes the transient (hidden) state probabilities after simulating evolution along
   * a branch
   * 
   * @param mesSeq an array the length of the nucleotide sequence,
   *               the elements of which are vectors containing probabilities
   *               for being in each of the allowable states at that place
   *               in the sequence
   */
  var computeProbSeq = function(mesSeq, time) {

    var p = function(m) {
      // for the particular molecular character, we need to sample the additional s-jimps
      var s = sample(Poisson({mu: mixedModel.rate * time}))
      var r = mExpQPtrs(m, molecularModel.Q, molecularModel.P_full, time, molecularModel.rate, s)
      return {s: s, r:r}
    }
    var mapRes = map(p, mesSeq)

    var rArray = map(function(obj) { return obj.r; }, mapRes);
  
    // Compute the sum of all s values
    var sSum = reduce(function(obj, accumulator) { return accumulator + obj.s; }, 0, mapRes);
    
    return {sSum: sSum, rArray: rArray}
  }

  var leftResult = computeProbSeq(leftMesSeq, leftTime)
  var leftProbSeq = leftResult.rArray 
  var leftNs = leftResult.sSum

  var rightResult = computeProbSeq(rightMesSeq, rightTime)
  var rightProbSeq = rightResult.rArray
  var rightNs = rightResult.sSum
  // now these will become the new messages after coalescing
  // elementwise leftProbSeq and rightProbSeq to get newMessageSequence
  var newMessageSequence = mapN(function(i) { return mathjs.dotMultiply(leftProbSeq[i], rightProbSeq[i]).valueOf() }, N)

  var computeCharProb = function(charMes, time, s) {
    return  mExpQPtrs(charMes, phenotypeModel.Q, phenotypeModel.P_full, time, phenotypeModel.rate, s)
  }

  var leftCharMes = computeCharProb(leftCharMes, leftTime, leftNs)
  var rightCharMes =  computeCharProb(rightCharMes, rightTime, rightNs)

  var newCharacterMessage = mathjs.dotMultiply(leftCharMes, rightCharMes).valueOf()

  return {
    type: 'leaf',
    age: binaryPathTree.age,
    index: binaryPathTree.index,
    messageSequence: newMessageSequence, // to avoid having to decode again
    characterMessage: newCharacterMessage
  } 
}


/**
 * 2023-08-12 probably buggy function due to mix of discrete and cont time
 * Calculates the product of a given matrix 'm' and the exponentiated product
 * of a substitution rate matrix 'Q', a time 't', and a rate 'r'.
 * 
 * The function computes the following operation: m * exp(Qtr), where exp(Qtr)
 * is the matrix exponentiation of the product of the substitution rate matrix
 * 'Q', the time 't', and the rate 'r'.
 *
 * @param {Array | Matrix} m - A matrix (as a 2D array or math.js Matrix) to be
 *                             multiplied by the exponentiated product of Q, t, and r.
 * @param {Array | Matrix} Q - A substitution rate matrix (as a 2D array or
 *                             math.js Matrix) to be multiplied by the time 't'
 *                             and the rate 'r', and then exponentiated.
 * @param {number} t - A time value to be multiplied by the substitution rate
 *                     matrix 'Q' and the rate 'r', and then exponentiated.
 * @param {number} r - A rate value to be multiplied by the substitution rate
 *                     matrix 'Q' and the time 't', and then exponentiated.
 * @returns {Matrix} - The result of the matrix multiplication m * exp(Qtr),
 *                     returned as a math.js Matrix object.
 */
var mExpQtrs = function(m, Q, t, r, s) {
  var expQt = mathjs.expm(mathjs.multiply(Q, t*r + s));
  return mathjs.multiply(m, expQt);
};


var mExpQPtrs = function(m, Q, P, t, r, s) {
  // Compute exp(Qtr)
  var expQtr = mathjs.expm(mathjs.multiply(Q, t * r));

  // Compute P^s
  var Ppower = mathjs.pow(P, s);

  // Multiply exp(Qtr) with P^s
  var productMatrix = mathjs.multiply(expQtr, Ppower);

  // Multiply m with the result
  return mathjs.multiply(m, productMatrix);
};



/**
 * Coalesces two branches so that they end up with the same outcome.
 * @param time branch length
 * @param leftStartStateSeq 
 * @param rightStartStateSeq 
 * @param leftStartCharState 
 * @param rightStartCharState 
 * @param phenotypeModel 
 * @param molecularModek 
 * @param mixedModel 
 */
var coalesce = function(time, leftStartStateSeq, rightStartStateSeq, leftStartCharState, rightStartCharState, phenotypeModel, molecularModel, mixedModel) {
  // Idea: resursively process the two sequences together, evolving every nucleotide
  // to the beginning of the branch and then conditioning on the same outcome
  // then process the phenotypic character
  // Note: we can use the singleStateEvolution function but we have to make sure
  // invert the models (invert the Q-matrix) if they are not symmetric.

  if (!(leftStartStateSeq.length == rightStartStateSeq.length)) {
    console.log("Sequences of differing length!")
    return -Infinity
  }

  var N = leftStartStateSeq.length

  // conditions and returns the total number of character transitions
  var f = function(i, leftNumTrans, rightNumTrans) {
    if (i == N) { // we are done
      return {leftNumTrans, rightNumTrans}
    } else {
      var leftRes = singleStateEvolution(0, leftStartStateSeq[i], 0, time, phenotypeModel, molecularModel, mixedModel)
      var rightRes = singleStateEvolution(0, rightStartStateSeq[i], 0, time, phenotypeModel, molecularModel, mixedModel)

      condition(  leftRes.endState == rightRes.endState )
      return f(i + 1, leftNumTrans + leftRes.numCharTrans, rightNumTrans + rightRes.numCharTrans)
    }
  }

  var numTrans = f(0, 0, 0)

  // now evolve the phenotypic character numTrans.leftNumTrans times on the left
  // and numTrans.rightNumTrans on the right and condition that they ended up the
  // same
  var leftChar = evolveChar(leftStartCharState, numTrans.leftNumTrans, phenotypeModel)
  var rightChar = evolveChar(rightStartCharState, numTrans.rightNumTrans, phenotypeModel)

  condition(leftChar == rightChar)

  return
}


/** Jukes and Cantor 1969 Substitution Model, Scaled
 * 
 * @return Q   Transition matrix according to JC69
 */
var jc69 = function() {
  return [
    [ -1, 1/3, 1/3, 1/3 ],
    [ 1/3, -1, 1/3, 1/3 ],
    [ 1/3, 1/3, -1, 1/3 ],
    [ 1/3, 1/3, 1/3, -1 ] ]
}


/**
 * Jukes-Cantor for a n-character state matrix (Mk model)
 * 
 * The instantaneous rates for any transition are the same.
 * 
 * @param n The number of states
 * 
 * @return Q Transition matrix
 */

var mk = function(n) {
  var rowf = function(row) {
      return mapN(function(col) { 
        if (col == row) {
          return -1
        } else return 1/(n-1)
      },
      n)
  }
  
  var Q = mapN(rowf, n)

  return Q
}


/**
 * 
 * Model, where phenotypic states can only go to
 * Transition probability only between neighboring states = 0.5
 * Transition probability between non-neighboring states = 0
 * Tranisition probability between the first and second state and between
 * the last and second to last state is 1.0
 * @param n The number of phenotypic characters
 * @returns 
 */
var calcQ_senderovPhenotypic = function(n) {
  var rowf = function(row) {
      return mapN(function(col) { 
        if (col == row) {
          return -1
        } else if ( (row == 0     && col == 1) || 
                    (row == (n-1) && col == (n-2)) ) {
          return 1
        } else if ( (col == (row - 1)) || 
                    (col == (row + 1)) ) {
          return 0.5
        } else return 0
      },
      n)
  }
  
  var Q = mapN(rowf, n)

  return Q
}

var possible_next_states = function(n) {
  var S = mapN(
    function(row) {
      var r = mapN(
        function(col) {
          return col
        },
        n
      )
      filter(function(e) {
        return e != row
      }, r)
    }, 
    n
  )
  return S
}


var possible_message_states = function(n) {
  return mapN(function(row) {
    return mapN(function(col) {
      return row === col ? 1 : 0;
    }, n);
  }, n);
};


/** Hasegawa, Kishino and Yano 1985
 *
 * @param p  A vector of base frequencies (length 4)
 * @param k  kappa parameter
 *
 * @return scaled Q matrix
 */
var hky85 = function(p, k) {
  var f = 1/(2*(p[0] + p[2])*(p[1] + p[3]) + 2*k*(p[0]*p[2] + p[1]*p[3]))
  var Q = [ 
      [ -f*(p[1] + k*p[2] + p[3]), f*p[1], f*k*p[2], f*p[3] ] ,
      [ f*p[0], -f*(p[0] + p[2] + k*p[3]) , f*p[2] , f*k*p[3] ] ,
      [ f*k*p[0], f*p[1], -f*(k*p[0] + p[1] + p[3]), f*p[3] ],
      [ f*p[0], f*k*p[1] , f*p[2] , -f*(p[0] + k*p[1] + p[2]) ] 
    ]
  return Q
}

/** Generalized Time-Reversible
 * 
 * The rates frequency vector encodes the transitions as follows
 *   r[0] : A -> C (alpha) 0 -> 1
 *   r[1] : A -> G (beta)  0 -> 2
 *   r[2] : A -> T (gamma) 0 -> 3
 *   r[3] : C -> G (delta) 1 -> 2
 *   r[4] : C -> T (eta)   1 -> 3
 *   r[5] : G -> T (nu)    2 -> 3
 
 *
 * @param p  Base frequency vector (length 4)
 * @param r  Rates vector (length 6)
 *
 * @return Q   Transition matrix
 */
var gtr = function(p, r) {
 var Q = [
  [ -(r[0]*p[1] + r[1]*p[2] + r[2]*p[3]), r[0]*p[1], r[1]*p[2], r[2]*p[3] ],
  [ r[0]*p[0], -(r[0]*p[0] + r[3]*p[2] + r[4]*p[3]), r[3]*p[2], r[4]*p[3] ],
  [ r[1]*p[0], r[3]*p[1], -(r[1]*p[0] + r[3]*p[1] + r[5]*p[3]), r[5]*p[3] ],
  [ r[2]*p[0], r[4]*p[1], r[5]*p[2], -(r[2]*p[0] + r[4]*p[1] + r[5]*p[2]) ] 
]
 var f = -1/(p[0]*Q[0][0] + p[1]*Q[1][1] * p[2]*Q[2][2] + p[3]*Q[3][3])
 return [ 
  [ f*Q[0][0], f*Q[0][1], f*Q[0][2], f*Q[0][3] ],
  [ f*Q[1][0], f*Q[1][1], f*Q[1][2], f*Q[1][3] ],
  [ f*Q[2][0], f*Q[2][1], f*Q[2][2], f*Q[2][3] ],
  [ f*Q[3][0], f*Q[3][1], f*Q[3][2], f*Q[3][3] ] ] 
}

/** 
  * Calculate transition probabilities
  * 
  * This function only works for 4x4 state matrices,
  * but is probably faster than the general case function
  * transition_probabilities_n(Q).
  * 
  * @param Q  Rate matrix
  * 
  * @return   A matrix encoding the transition probabilities
  *           from one state to another 
  */
var transition_probabilities = function(Q) {
  var P = [ 
    [-Q[0][1]/Q[0][0], -Q[0][2]/Q[0][0], -Q[0][3]/Q[0][0] ],
    [-Q[1][0]/Q[1][1], -Q[1][2]/Q[1][1], -Q[1][3]/Q[1][1] ],
    [-Q[2][0]/Q[2][2], -Q[2][1]/Q[2][2], -Q[2][3]/Q[2][2] ],
    [-Q[3][0]/Q[3][3], -Q[3][1]/Q[3][3], -Q[3][2]/Q[3][3] ] 
  ]
  return P
}


/** 
 * Calculate transition probabilities from any square matrix Q
 * n x n
 * 
 * @param Q  Rate matrix
 * @return Transition probabilities matrix n x (n-1),
 *         each row encodes the transition probabilities
 *         to the other n - 1 states
*/
var transition_probabilities_n = function(Q) {
  var P = mapN(
    function(row) {
      var r = mapN(
        function(col) {
          return -Q[row][col]/Q[row][row]
        },
        Q.length
      )
      filter(function(e) {
        return e != -1
      }, r)
    }, 
    Q.length
  )
  return P
}


var transition_probabilities_full = function(Q) {
  var P = mapN(
    function(row) {
      return mapN(
        function(col) {
          if (row !== col) {
            return -Q[row][col] / Q[row][row];
          } else {
            return 0; // Diagonal entries in P are 0
          }
        },
        Q.length
      );
    }, 
    Q.length
  );
  return P;
}


/**
 * Makes a full model from JC69 and a two state Mk
 * 
 * a very special case
 * 
 * @param lam molecular model rate 
 * @param mu phenotypic model rate 
 * @param nu mixed model rate
 * 
 * @return Full model Q matrix
 */
var makeJC69x2stateMk = function(lam, mu, nu) {
  
  var fullQ = [
  //(T,0)         (T,1)        (C,0)      (C,1)      (A,0)       (A,1)      (G,0)        (G,1)   
    [ -nu-mu-lam, mu,          lam/3,     nu/3,      lam/3,       nu/3,      lam/3,      nu/3 ],   // (T,0)
    [ mu,        -nu-mu-lam,   nu/3,      lam/3,      nu/3,       lam/3,     nu/3,       lam/3 ],  // (T,1)
    [ lam/3,      nu/3,       -nu-mu-lam, mu,        lam/3,       nu/3,      lam/3,      nu/3 ],   // (C,0)
    [ nu/3,       lam/3,       mu,        -nu-mu-lam, nu/3,       lam/3,     nu/3,       lam/3 ],  // (C,1)
    [ lam/3,      nu/3,        lam/3,     nu/3,       -nu-mu-lam, mu,        lam/3,      nu/3 ],   // (A,0)
    [ nu/3,       lam/3,       nu/3,      lam/3,      mu,         -nu-mu-lam, nu/3,      lam/3 ],  // (A,1)
    [ lam/3,      nu/3,        lam/3,     nu/3,       lam/3,      nu/3,      -nu-mu-lam, mu ],     // (G,0)
    [ nu/3,       lam/3,       nu/3,      lam/3,      nu/3,       lam/3,      mu,        -nu-mu-lam ]  // (G,1)   
  ];

  return fullQ;
}




/**
 * Process the tree recursively and add s-jumps
 * need to preserve annotations
 * 
 * @param tree
 * @param mixedModel
 * 
 * @return a modified tree with s-jumps
 */
var add_sjumps = function(tree, mixedModel) {
  if (tree.type == 'leaf') {
    return tree
  } else { // 'node'
    var leftTime = tree.age - tree.left.age
    var rightTime = tree.age - tree.right.age
    var leftNs = poisson({mu: mixedModel.rate * leftTime})
    var rightNs = poisson({mu: mixedModel.rate * rightTime})

    var newTree = {
      type: 'node',
      leftNs: leftNs,
      rightNs: rightNs,
      age: tree.age,
      index: tree.index,
      left: add_sjumps(tree.left, mixedModel),
      right: add_sjumps(tree.right, mixedModel)
    }

    return newTree
  }
}


var getSequenceLength = function(tree) {
  if (tree.type == 'leaf') {
    return tree.stateSequence.length
  } else return getSequenceLength(tree.left)
}


/**
 * Coalesces an s-tree w.r.t. character
 * we have the message to root w.r.t. to the character
 * @param sTree 
 * @param phenotypeModel 
 * @returns coalesced s tree with .characterMessage property
 */
var coalesceSTreeCharacter = function(sTree, phenotypeModel) {
  if (sTree.left.type == 'leaf' && sTree.right.type == 'leaf') {
    return coalesceCharacterBPT(sTree, phenotypeModel)
  } else if (sTree.left.type == 'leaf' && sTree.right.type == 'node') {
      var newTree = {
        type: 'node',
        left: sTree.left,
        right: coalesceSTreeCharacter(sTree.right, phenotypeModel),
        age: sTree.age,
        index: sTree.index,
        leftNs: sTree.leftNs,
        rightNs: sTree.rightNs
      }
    return coalesceCharacterBPT(newTree, phenotypeModel)
  } else if (sTree.left.type == 'node' && sTree.right.type == 'leaf') {
      var newTree = {
        type: 'node',
        left: coalesceSTreeCharacter(sTree.left, phenotypeModel),
        right: sTree.right,
        age: sTree.age,
        index: sTree.index,
        leftNs: sTree.leftNs,
        rightNs: sTree.rightNs
      }
      return coalesceCharacterBPT(newTree, phenotypeModel)
  } else { // node and node
      var newTree = {
        type: 'node',
        left: coalesceSTreeCharacter(sTree.left, phenotypeModel),
        right: coalesceSTreeCharacter(sTree.right, phenotypeModel),
        age: sTree.age,
        index: sTree.index,
        leftNs: sTree.leftNs,
        rightNs: sTree.rightNs
      }
      return coalesceCharacterBPT(newTree, phenotypeModel)
  }
}



/**
 * A function that coalesces the BPT, but only w.r.t. characterMessage
 * contrast with coalesce_binaryPathTree2
 * 
 * @param sTree 
 * @param phenotypeModel 
 * @returns 
 */
var coalesceCharacterBPT = function(sTree, phenotypeModel) {
  var leftTime = sTree.age - sTree.left.age
  var rightTime = sTree.age - sTree.right.age
  var leftCharMes = getCharacterMessage(sTree.left, phenotypeModel.characters.length)
  var rightCharMes = getCharacterMessage(sTree.right, phenotypeModel.characters.length)
  var leftNs = sTree.leftNs
  var rightNs = sTree.rightNs
  var computeCharProb = function(charMes, time, s) {
    return  mExpQtrs(charMes, phenotypeModel.Q, time, phenotypeModel.rate, s)
  }
  var leftCharMes = computeCharProb(leftCharMes, leftTime, leftNs)
  var rightCharMes =  computeCharProb(rightCharMes, rightTime, rightNs)
  var newCharacterMessage = mathjs.dotMultiply(leftCharMes, rightCharMes).valueOf()
  return {
    type: 'leaf',
    age: sTree.age,
    index: sTree.index,
    characterMessage: newCharacterMessage,
    leftNs: sTree.leftNs,
    rightNs: sTree.rightNs
  }
}


/**
 * Coalesces an STree w.r.t. a single nucleotide
 * @param i 
 * @param N seq length
 * @param sTree 
 * @param molecularModel 
 * @returns 
 */
var coalesceSTreeSingleNuc = function(i, N, sTree, molecularModel) {
  if (sTree.left.type == 'leaf' && sTree.right.type == 'leaf') {
    return(coalesceSingleNucBPT(i, N, sTree, molecularModel))
  } else if (sTree.left.type == 'leaf' && sTree.right.type == 'node') {
      var newTree = {
        type: 'node',
        left: sTree.left,
        right: coalesceSTreeSingleNuc(i, N, sTree.right, molecularModel),
        age: sTree.age,
        index: sTree.index,
        leftNs: sTree.leftNs,
        rightNs: sTree.rightNs
      }
    return coalesceSingleNucBPT(i, N, newTree, molecularModel)
  } else if (sTree.left.type == 'node' && sTree.right.type == 'leaf') {
      var newTree = {
        type: 'node',
        left: coalesceSTreeSingleNuc(i, N, sTree.left, molecularModel),
        right: sTree.right,
        age: sTree.age,
        index: sTree.index,
        leftNs: sTree.leftNs,
        rightNs: sTree.rightNs
      }
      return coalesceSingleNucBPT(i, N, newTree, molecularModel)
  } else { // node and node
      var newTree = {
        type: 'node',
        left: coalesceSTreeSingleNuc(i, N, sTree.left, molecularModel),
        right: coalesceSTreeSingleNuc(i, N, sTree.right, molecularModel),
        age: sTree.age,
        index: sTree.index,
        leftNs: sTree.leftNs,
        rightNs: sTree.rightNs,

      }
      return coalesceSingleNucBPT(i, N, newTree, molecularModel)
  }
}


/**
 * Coalesces a tree w.r.t. a single nucleotide using the full model
 * @param i 
 * @param tree annotated tree 
 * @param fullModel 
 * @returns 
 */
var coalesceTreeFullModel = function(i, tree, fullModel) {
  if (tree.left.type == 'leaf' && tree.right.type == 'leaf') {
    return(coalesceBPTFullModel(i, tree, fullModel))
  } else if (tree.left.type == 'leaf' && tree.right.type == 'node') {
      var newTree = {
        type: 'node',
        left: tree.left,
        right: coalesceTreeFullModel(i, tree.right, fullModel),
        age: tree.age,
        index: tree.index
      }
    return coalesceBPTFullModel(i, newTree, fullModel)
  } else if (tree.left.type == 'node' && tree.right.type == 'leaf') {
      var newTree = {
        type: 'node',
        left: coalesceTreeFullModel(i, tree.left, fullModel),
        right: tree.right,
        age: tree.age,
        index: tree.index
        
      }
      return coalesceBPTFullModel(i, newTree, fullModel)
  } else { // node and node
      var newTree = {
        type: 'node',
        left: coalesceTreeFullModel(i, tree.left, fullModel),
        right: coalesceTreeFullModel(i, tree.right, fullModel),
        age: tree.age,
        index: tree.index
      }
      return coalesceBPTFullModel(i, newTree, fullModel)
  }
}


var coalesceSingleNucBPT = function(i, N, sTree, molecularModel) {
  var leftTime = sTree.age - sTree.left.age
  var rightTime = sTree.age - sTree.right.age
  var leftMessage = getSingleNucMessage(i, sTree.left)
  var rightMessage = getSingleNucMessage(i, sTree.right)
  var leftNs = sTree.leftNs
  var rightNs = sTree.rightNs
  var p = 1/N

  var computeProbSingleNuc = function(i, message, time, s) {
    var p = function(m) {
      mExpQtrs(m, molecularModel.Q, time, molecularModel.rate, s)
    }
    return p(message)
  }
  
  var leftProbSingleNuc = computeProbSingleNuc(i, leftMessage, leftTime, leftNs*p)
  var rightProbSingleNuc = computeProbSingleNuc(i, rightMessage, rightTime, rightNs*p)
  var newSingleNucMessage = mathjs.dotMultiply(leftProbSingleNuc, rightProbSingleNuc).valueOf()

  return {
    type: 'leaf',
    age: sTree.age,
    index: sTree.index,
    singleNucMessage: newSingleNucMessage,
    position: i,
    leftNs: sTree.leftNs,
    rightNs: sTree.rightNs
  }
}



var coalesceBPTFullModel = function(i, tree, fullModel) {
  var leftTime = tree.age - tree.left.age
  var rightTime = tree.age - tree.right.age
  // What are the messages here?  Since we use the full model,
  // the messages are likelihood vectors over the nuc x character possible states
  var leftMessage = getCombinedMessage(i, tree.left)
  var rightMessage = getCombinedMessage(i, tree.right)
 
  var computeProbSingleNuc = function(message, time, s) {
    var p = function(m) {
      mExpQtrs(m, fullModel.Q, time, fullModel.rate, s)
    }
    return p(message)
  }
  
  var leftProbSingleNuc = computeProbSingleNuc(leftMessage, leftTime, 0)
  var rightProbSingleNuc = computeProbSingleNuc(rightMessage, rightTime, 0)
  var newMessage = mathjs.dotMultiply(leftProbSingleNuc, rightProbSingleNuc).valueOf()

  return {
    type: 'leaf',
    age: tree.age,
    index: tree.index,
    combinedMessage: newMessage,
    position: i
  }
}